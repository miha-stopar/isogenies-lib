use anyhow::{bail, Result};
use rand::Rng;
use rug::{integer::IsPrime, Integer};

use crate::{error::NotQuadraticResidueError, util::Big};

use super::quadratic_order::QuadraticOrderEl;

/// `QuadraticIdeal` generated by `gen1` and `gen2`. The imaginary part of generator `gen1`
/// needs to be 0. This way the ideal norm can be computed as gcd(`gen1`, `gen2`).
#[derive(Clone, Debug, Default, PartialEq)]
pub struct QuadraticIdeal {
    pub gen1: QuadraticOrderEl,
    pub gen2: QuadraticOrderEl,
}

impl QuadraticIdeal {
    /// Create a quadratic ideal with the two given generators.
    pub fn new(gen1: QuadraticOrderEl, gen2: QuadraticOrderEl) -> Self {
        assert!(gen1.b == 0.big()); // TODO: without this the norm cannot be computed simply by gcd both generators
        assert!(gen1.a.clone().gcd(&gen2.norm()) == gen1.a);

        QuadraticIdeal { gen1, gen2 }
    }

    /// Return the ideal norm.
    pub fn norm(&self) -> Integer {
        self.gen1.norm().gcd(&self.gen2.norm())
    }

    /// Return the random ideal element a * self.gen1 + b * self.gen2 where a, b are chosen randomly from [0, `bound`].
    /// Not cryptographically secure.
    pub fn random_element(&self, bound: usize) -> QuadraticOrderEl {
        let a = rand::thread_rng().gen_range(0..bound);
        let b = rand::thread_rng().gen_range(0..bound);

        self.gen1.clone() * a + self.gen2.clone() * b
    }

    pub fn equivalent_prime_ideal(&self) -> Result<QuadraticIdeal> {
        // TODO: check implemention and write a test
        let norm = self.norm();
        let mut bound = 1;
        let mut rng = rand::thread_rng();
        for _ in 0..99 {
            let i = rng.gen_range(0..=bound);
            let j = rng.gen_range(0..=bound);

            let sigma = self.gen1.clone() * i + self.gen2.clone() * j;
            let c = sigma.norm() / norm.clone();

            let is_prob_prime = c.is_probably_prime(30);
            if is_prob_prime == IsPrime::Probably || is_prob_prime == IsPrime::Yes {
                let g1 = self.gen1.clone() * sigma.conjugate() / norm.clone();
                let g2 = self.gen2.clone() * sigma.clone() / norm.clone();

                return Ok(QuadraticIdeal::new(g1, g2));
            } else {
                bound += 1;
            }
        }

        bail!(NotQuadraticResidueError());
    }
}

#[cfg(test)]
mod tests {
    use crate::{quaternion::quadratic_order::QuadraticOrder, util::Big};

    #[test]
    fn random_ideal() {
        let d = -11.big();
        let conductor = 19457.big();
        let denom = 2.big();

        let order = QuadraticOrder::new(d.clone(), denom.clone(), conductor.clone());
        order.random_ideal();
    }
}
