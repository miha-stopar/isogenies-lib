use rug::Integer;
use std::ops::{Add, Div, Mul};

use crate::{
    quaternion::quadratic_ideal::QuadraticIdeal,
    util::{big_bits_len, generate_random_prime, sqrt_mod_p, Big},
};

/// Order in a number field with defining polynomial x^2 - d where d is negative
/// (the field discriminant is -d).
/// The generators of the order are 1 and (1 + theta)/gen_denom.
/// Let's denote theta = sqrt(d). The elements of the field are x + y * theta.
/// Note that the discriminant of a number field Q(sqrt(d)) is d when
/// d % 4 = 3 (currently only this case is supported).
/// The order conductor is stored in the variable `conductor`.
/// The order discriminant can be computed as: order_disc = conductor**2 * field_disc.
#[derive(Clone, Debug, Default, PartialEq)]
pub struct QuadraticOrder {
    pub d: Integer,
    pub gen_denom: Integer,
    pub conductor: Integer,
    pub order_disc_abs: Integer,
}

impl QuadraticOrder {
    pub fn new(d: Integer, gen_denom: Integer, conductor: Integer) -> Self {
        // Only negative discriminants are supported:
        assert!(d < 0.big());
        // Only discriminants that 3 modulo 4 are supported:
        assert!(d.clone() % 4 == -3.big());
        let order_disc_abs = -d.clone() * conductor.clone() * conductor.clone(); // assumes negative discriminant

        QuadraticOrder {
            d: d.clone(),
            gen_denom,
            conductor: conductor.clone(),
            order_disc_abs,
        }
    }

    /// Return a random ideal in a quadratic order. The returned ideal is of the form (l, a + theta)
    /// where l is a prime number.
    ///
    /// An order element a + theta is found such that `l` divides its norm.
    /// Note that the norm of the element a + b * theta is a**2 - d * b**2 (d is negative).
    /// It holds a**2 - d * b**2 = (a + b * theta) * (a - b * theta).
    /// The norm of the element a + theta is thus a**2 - d.
    /// Having such a + theta would mean that the ideal (l) in Q(sqrt(d)) is split.
    /// Heuristically, the classes of such ideals are uniformly random.
    ///
    /// In general, over a quadratic field, ideals (l) generated by integer primes l are one of three kinds:
    /// - inert, meaning that the ideal (l) itself is a prime ideal. But this
    /// one is principal (generated by l), so its class is trivial.
    /// - ramified, meaning that the ideal (l) is the square of a prime ideal of norm l.
    /// This means the associated class has order 1 or 2 in the class group and this happens only at finitely many primes l.
    /// - split, meaning that the ideal (l) is a product of two conjugate prime ideals of norm l.
    ///
    /// Every ideal class has a representative of norm bounded (Minowski bound) by approximately the square root
    /// of the (absolute value of) discriminant, so we choose l up to sqrt(|disc(O)|).
    pub fn random_ideal(&self) -> QuadraticIdeal {
        let s = self.order_disc_abs.clone().sqrt();
        let bound_bits = big_bits_len(s);

        loop {
            let l = generate_random_prime(bound_bits, false);
            let neg_mod = (-1 * self.order_disc_abs.clone()) % l.clone();
            let s_res = sqrt_mod_p(neg_mod, l.clone());
            let s = match s_res {
                Ok(s) => s,
                Err(_) => {
                    continue;
                }
            };

            let is_right_sqrt = ((s.clone() * s.clone()) % l.clone() + self.order_disc_abs.clone())
                % l.clone()
                == 0.big();

            if is_right_sqrt {
                let check = (s.clone() * s.clone() + self.order_disc_abs.clone()) % l.clone();
                assert!(check == 0.big());
                // ideal (l, a + theta):
                let el1 = QuadraticOrderEl::new(l, 0.big(), 1.big(), self.clone());
                let el2 = QuadraticOrderEl::new(s.clone(), 1.big(), 1.big(), self.clone());

                return QuadraticIdeal::new(el1, el2);
            }
        }
    }
}

/// `QuadraticOrderEl` presents an element in the order of the number field.
/// The element is a / denom + b / denom * theta where theta = sqrt(d) and the number field is Q(sqrt(d)).
#[derive(Debug, Default, Clone, PartialEq)]
pub struct QuadraticOrderEl {
    pub a: Integer,
    pub b: Integer,
    pub denom: Integer,
    pub order: QuadraticOrder,
}

impl QuadraticOrderEl {
    pub fn new(a: Integer, b: Integer, denom: Integer, order: QuadraticOrder) -> Self {
        QuadraticOrderEl { a, b, denom, order }
    }

    pub fn conjugate(&self) -> QuadraticOrderEl {
        QuadraticOrderEl::new(
            self.a.clone(),
            -self.b.clone(),
            self.denom.clone(),
            self.order.clone(),
        )
    }

    pub fn norm(&self) -> Integer {
        // Note: only negative d supported for now:
        assert!(self.order.d.clone() < 0.big());
        let num = self.a.clone() * self.a.clone()
            + self.b.clone() * self.b.clone() * self.order.order_disc_abs.clone();
        num / (self.denom.clone() * self.denom.clone())
    }

    pub fn normalize(&self) -> QuadraticOrderEl {
        let mut gcd = self.a.clone().gcd(&self.b);
        gcd = gcd.gcd(&self.denom);
        if gcd > 1.big() {
            QuadraticOrderEl::new(
                self.a.clone() / gcd.clone(),
                self.b.clone() / gcd.clone(),
                self.denom.clone() / gcd,
                self.order.clone(),
            )
        } else {
            self.clone()
        }
    }

    /// Return `u`, `v` such that self = `u` + `v` * `el`.
    pub fn express_with_el(&self, el: QuadraticOrderEl) -> (Integer, Integer) {
        let v = self.b.clone() * el.denom.clone() / (el.b.clone() * self.denom.clone());
        let lcm = self.denom.clone().lcm(&el.denom.clone());
        let mut u = self.a.clone() * lcm.clone() / self.denom.clone()
            - v.clone() * el.a.clone() * lcm.clone() / el.denom.clone();
        u = u / lcm;
        let check_el = QuadraticOrderEl::new(u.clone(), 0.big(), 1.big(), self.order.clone())
            + el.clone() * v.clone();
        assert!(*self == check_el);

        (u, v)
    }

    /// Take the two given elements and return two equivalent ones with the same denominator.
    fn put_to_same_denom(
        a: QuadraticOrderEl,
        b: QuadraticOrderEl,
    ) -> (QuadraticOrderEl, QuadraticOrderEl) {
        let gcd = a.denom.clone().gcd(&b.denom);
        let mut new_a = QuadraticOrderEl::default();
        let mut new_b = QuadraticOrderEl::default();

        new_a.denom = a.clone().denom / gcd.clone();
        new_b.denom = b.clone().denom / gcd;

        new_a = a.clone() * new_b.clone().denom;
        new_b = b.clone() * new_a.clone().denom;

        new_a.denom = b.denom * new_a.denom;
        new_b.denom = a.denom * new_b.denom;

        (new_a, new_b)
    }
}

impl Add for QuadraticOrderEl {
    type Output = Self;

    fn add(self, other: QuadraticOrderEl) -> QuadraticOrderEl {
        let (new_a, new_b) = QuadraticOrderEl::put_to_same_denom(self, other);
        let el = QuadraticOrderEl {
            a: new_a.a + new_b.a,
            b: new_a.b + new_b.b,
            denom: new_a.denom,
            order: new_b.order,
        };

        el.normalize()
    }
}

impl<T> Mul<T> for QuadraticOrderEl
where
    Integer: From<T>,
    T: Clone,
{
    type Output = Self;

    fn mul(self, other: T) -> QuadraticOrderEl {
        let el = QuadraticOrderEl {
            a: self.a * Integer::from(other.clone()),
            b: self.b * Integer::from(other.clone()),
            denom: self.denom,
            order: self.order,
        };

        el.normalize()
    }
}

impl<T> Div<T> for QuadraticOrderEl
where
    Integer: From<T>,
    T: Clone,
{
    type Output = Self;

    fn div(self, other: T) -> QuadraticOrderEl {
        let other_big = Integer::from(other.clone());
        assert!(other_big != 0.big());

        let coeffs = vec![self.a.clone(), self.b.clone()];
        let non_zero = coeffs.iter().filter(|x| **x != 0.big());
        let gcd = non_zero
            .into_iter()
            .fold(other_big.clone(), |acc, x| acc.gcd(x));

        if gcd == other_big {
            QuadraticOrderEl {
                a: self.a / Integer::from(other.clone()),
                b: self.b / Integer::from(other.clone()),
                denom: self.denom,
                order: self.order,
            }
        } else {
            QuadraticOrderEl {
                a: self.a,
                b: self.b,
                denom: self.denom * Integer::from(other.clone()),
                order: self.order,
            }
        }
    }
}

impl Mul<QuadraticOrderEl> for QuadraticOrderEl {
    type Output = Self;

    fn mul(self, other: QuadraticOrderEl) -> QuadraticOrderEl {
        let a = self.a.clone() * other.a.clone()
            + self.order.d.clone() * self.b.clone() * other.b.clone();
        let b = self.b.clone() * other.a.clone() + self.a.clone() * other.b.clone();

        let el = QuadraticOrderEl {
            a: a,
            b: b,
            denom: self.denom.clone() * other.denom,
            order: self.order,
        };

        el.normalize()
    }
}
